<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
	xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
	xmlns:int="http://www.springframework.org/schema/integration"
	xmlns:context="http://www.springframework.org/schema/context"
	xmlns:int-amqp="http://www.springframework.org/schema/integration/amqp"
	xmlns:int-ws="http://www.springframework.org/schema/integration/ws"
	xmlns:rabbit="http://www.springframework.org/schema/rabbit"
	xmlns:int-stream="http://www.springframework.org/schema/integration/stream"
	xmlns:oxm="http://www.springframework.org/schema/oxm"
	xmlns:int-jdbc="http://www.springframework.org/schema/integration/jdbc"
	xmlns:jdbc="http://www.springframework.org/schema/jdbc"
	xmlns:aop="http://www.springframework.org/schema/aop"
	xmlns:cloud="http://schema.cloudfoundry.org/spring"
	xmlns:int-event="http://www.springframework.org/schema/integration/event"
	xsi:schemaLocation="http://www.springframework.org/schema/integration/amqp http://www.springframework.org/schema/integration/amqp/spring-integration-amqp.xsd
		http://www.springframework.org/schema/integration http://www.springframework.org/schema/integration/spring-integration.xsd
		http://www.springframework.org/schema/integration/ws http://www.springframework.org/schema/integration/ws/spring-integration-ws.xsd
		http://www.springframework.org/schema/integration/stream http://www.springframework.org/schema/integration/stream/spring-integration-stream.xsd
		http://www.springframework.org/schema/rabbit http://www.springframework.org/schema/rabbit/spring-rabbit.xsd
		http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd
		http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd
		http://www.springframework.org/schema/oxm http://www.springframework.org/schema/oxm/spring-oxm.xsd
	    http://www.springframework.org/schema/integration/jdbc http://www.springframework.org/schema/integration/jdbc/spring-integration-jdbc.xsd
	    http://www.springframework.org/schema/jdbc http://www.springframework.org/schema/jdbc/spring-jdbc.xsd
	    http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop.xsd
	    http://schema.cloudfoundry.org/spring http://schema.cloudfoundry.org/spring/cloudfoundry-spring.xsd
	    http://www.springframework.org/schema/integration/event http://www.springframework.org/schema/integration/event/spring-integration-event.xsd">
	    

	<context:component-scan base-package="ie.cit.cloud.mvc" />
	
	
	<!-- infrastructure setup -->



 	<rabbit:connection-factory id="connectionFactory" />
		<rabbit:template id="amqpTemplate" 
		connection-factory="connectionFactory" />
	
		<rabbit:admin connection-factory="connectionFactory" />
		<rabbit:queue name="epos.loyalty"  />
		<rabbit:queue name="epos.creditcard" />
		<rabbit:queue name="epos.promotion" />
		<rabbit:queue name="epos.voucher" />
		<rabbit:queue name="epos.backup.log" />
	
	<!-- setup exchange/queue infrastructure, simple binding without routing key -->
	<rabbit:fanout-exchange name="epos.main.exchange.fanout">
		<rabbit:bindings>
			<rabbit:binding queue="epos.loyalty"  />
			<rabbit:binding queue="epos.creditcard"  />
			<rabbit:binding queue="epos.promotion"  />
			<rabbit:binding queue="epos.voucher"  />
		</rabbit:bindings>
	</rabbit:fanout-exchange>
	
	<rabbit:direct-exchange name="epos.direct.exchange.log">
			<rabbit:bindings>
				<rabbit:binding queue="epos.backup.log"  />
			</rabbit:bindings>
	</rabbit:direct-exchange>

	<int:annotation-config/>
	
	<!-- sending messages -->
	<int:channel id="toRabbit"></int:channel>
	<int-amqp:outbound-channel-adapter id="amqp-outbound-adapter" amqp-template="amqpTemplate"
		exchange-name="epos.main.exchange.fanout" channel="toRabbit"
		routing-key="epos.main.exchange.fanout"
		mapped-request-headers="message_*, __*, amqp_*" 
		/>
		
	<!-- sending messages -->
	<int:channel id="toLogChannel" />
	<int-amqp:outbound-channel-adapter amqp-template="amqpTemplate"
		exchange-name="epos.direct.exchange.log" channel="toLogChannel"
		mapped-request-headers="message_*, __*, amqp_*" />


<!-- 
***
*** END OF AMQP SETUP
***
 -->
 
 
 
 
 
 <!-- 
***
*** THE FOLLOWING SECTION CONFIGURES THE MARSHELLERS REQUIRED FOR THE MESSAGING 
*** INFRASTRUCTURE AND THEN LEADS INTO THE THE 3RD PARTY WEB SERVICE CALLS
***
 -->


	<!-- Receiving messages from queues 
		These are then passed to a SI outbound web service adapter
		Before this can happen however, they need to be converted
		form Text to a Java object (handled by marshallingMessageConverter)
		This can simply be repeated for each Outbound Webservice as required
		thus making the application very scalable
	-->
	 <bean id="marshallingMessageConverter" class="org.springframework.amqp.support.converter.MarshallingMessageConverter">
	 		<property name="marshaller" ref="marshaller" />
	 		<property name="unmarshaller" ref="marshaller" />
	 </bean>
	 <!-- access web service using spring integration -->
	 <!-- The JAXB elements to the can either scan the entire path such as : contextPath="ie.cit.cloud.pointofsale"
		OR 
		specify the individual classes to be bound
		<oxm:class-to-be-bound name="ie.cit.cloud.pointofsale.SalesTransactionRequest"/>
	    <oxm:class-to-be-bound name="ie.cit.cloud.pointofsale.LoyaltyResponse"/>
	    <oxm:class-to-be-bound name="ie.cit.cloud.pointofsale.CreditcardResponse"/>
	    <oxm:class-to-be-bound name="ie.cit.cloud.pointofsale.VoucherResponse"/>
	    <oxm:class-to-be-bound name="ie.cit.cloud.pointofsale.PromotionResponse"/>
		 -->
	<oxm:jaxb2-marshaller id="marshaller" contextPath="ie.cit.cloud.pointofsale"> 
	</oxm:jaxb2-marshaller>

<!-- 
***
*** CALLS TO EXTERNAL THIRD PARTY WEB SERVICES USING 
*** SPRING INTEGRATION OUTBOUND WEB SERVICE ADAPTER
***
 -->
	<!-- 
	Access messages from the Fanout Exchange using and AMQP inbound adapter
	This message is then passed to the outbound LOYALTY WS adapter
	 -->

	<int-amqp:inbound-channel-adapter 
	id="fromRabbit_loyalty_adapter"
	channel="fromRabbit_loyalty"
	queue-names="epos.loyalty" 
	connection-factory="connectionFactory"  
	mapped-request-headers="message_*, __*, amqp_*"	
	message-converter="marshallingMessageConverter"
	error-channel="eventErrorChannel"
	/>
	<int:channel id="fromRabbit_loyalty"/>
	<int-ws:outbound-gateway id="loyaltyGateway"
		request-channel="fromRabbit_loyalty"
		reply-channel="aggregateChannel"
		uri="http://loyalty.cloudfoundry.com/loyalty/baskets"
		marshaller="marshaller"
		unmarshaller="marshaller"
	/>
		
	<!-- 
	Access messages from the Fanout Exchange using and AMQP inbound adapter
	This message is then passed to the credit card outbound WS adapter
	 -->
	<int-amqp:inbound-channel-adapter 
	id="fromRabbit_creditcard_adapter"
	channel="fromRabbit_creditcard"
	queue-names="epos.creditcard" 
	connection-factory="connectionFactory"  
	mapped-request-headers="message_*, __*, amqp_*"	
	message-converter="marshallingMessageConverter"
	error-channel="eventErrorChannel"
	/>
	<int:channel id="fromRabbit_creditcard"/>
	<int-ws:outbound-gateway id="creditcardGateway"
		request-channel="fromRabbit_creditcard"
		reply-channel="aggregateChannel"
		uri="http://creditcard.cloudfoundry.com/creditcard/baskets"
		marshaller="marshaller"
		unmarshaller="marshaller"
	/>
	<!-- 
	Access messages from the Fanout Exchange using and AMQP inbound adapter
	This message is then passed to the outbound WS adapter
	 -->
	<int-amqp:inbound-channel-adapter 
	id="fromRabbit_promotion_adapter"
	channel="fromRabbit_promotion"
	queue-names="epos.promotion" 
	connection-factory="connectionFactory"  
	mapped-request-headers="message_*, __*, amqp_*"	
	message-converter="marshallingMessageConverter"
	error-channel="eventErrorChannel"
	/>
	<int:channel id="fromRabbit_promotion"/>
	<int-ws:outbound-gateway id="promotionGateway"
		request-channel="fromRabbit_promotion"
		reply-channel="aggregateChannel"
		uri="http://promotion.cloudfoundry.com/promotion/baskets"
		marshaller="marshaller"
		unmarshaller="marshaller"
	/>
	
		<!-- 
	Access messages from the Fanout Exchange using and AMQP inbound adapter
	This message is then passed to the outbound WS adapter
		<int:channel id="fromRabbit.epos.voucher"/>
		
	 -->

	<int-amqp:inbound-channel-adapter 
	id="fromRabbit_voucher_adapter"
	channel="fromRabbit_voucher"
	queue-names="epos.voucher" 
	connection-factory="connectionFactory"  
	mapped-request-headers="message_*, __*, amqp_*"	
	message-converter="marshallingMessageConverter"
	error-channel="eventErrorChannel"
	/>
	<int:channel id="fromRabbit_voucher"/>
	<int-ws:outbound-gateway id="voucherGateway"
		request-channel="fromRabbit_voucher"
		reply-channel="aggregateChannel"
		uri="http://voucher.cloudfoundry.com/voucher/baskets"
		marshaller="marshaller"
		unmarshaller="marshaller"
	/>

<!-- 
	**** AGGREGATOR CHANNEL WILL GO HERE ****
		EXAMPLE from KRAMS
		<aggregator input-channel="aggregateChannel"
		  output-channel="wsChannel" ref="productAggregatorBean" method="send"
		  release-strategy="productAggregatorBean" release-strategy-method="release"
		  correlation-strategy="productAggregatorBean" correlation-strategy-method="correlate"
		  send-partial-result-on-expiry="false" />
		  	
		  <beans:bean id="productAggregatorBean" class="org.krams.tutorial.si.ProductAggregator" />
		
			<int:aggregator input-channel="aggregateChannel"
		  output-channel="output" ref="amqpMessageAggregator" method="send"
		  release-strategy="amqpMessageAggregator" release-strategy-method="release"
		  correlation-strategy="amqpMessageAggregator" correlation-strategy-method="correlate"
		  send-partial-result-on-expiry="false" />
		  
		  release-strategy-expression="size() == 2"
		
 -->	
	  <bean id="amqpMessageAggregator" class="ie.cit.cloud.mvc.service.amqp.amqpMessageAggregator" />
	<int:channel id="aggregateChannel"/>
	<int:aggregator input-channel="aggregateChannel"
		  output-channel="output" 
		  correlation-strategy="amqpMessageAggregator" correlation-strategy-method="correlate"
		  release-strategy="amqpMessageAggregator" release-strategy-method="release"
		  release-strategy-expression="size() == 2"
		  send-partial-result-on-expiry="true"
		 />

	 
	
<!-- 
***
*** END OF CALLS TO EXTERNAL THIRD PARTY WEB SERVICES USING 
*** SPRING INTEGRATION OUTBOUND WEB SERVICE ADAPTER
***
 -->
	
	
	 <!-- 
	 *********************************** 
		 using the Service activator as the 'client for the 
		 what we will be testing is the response time of all service's  being call back at the same time versus the
		 sequential nature of the ws outbound adapter.
		 1 message processed by multiple services in paralell as apposed to sequentially by the webservice
		***********************************  
		--> 
	
    
    
    <!-- *********************************** 
		 mySQL CONNECTION SETUP To Handle logging from
		 the JDBC Out-bound Adapter.
	***********************************  --> 
	<!-- Initialise the mySQL db -->
	<jdbc:initialize-database data-source="dataSource">
		<jdbc:script location="classpath:META-INF/mysql/db-schema.sql" />
	</jdbc:initialize-database>
 	<!-- Assign the db props placeholder -->
 	<bean 
 		class="org.springframework.beans.factory.config.PropertyPlaceholderConfigurer">
		<property name="location" >
				<value>classpath:META-INF/mysql/database.properties</value>  
		</property>
	</bean>
	
	<!-- Configure the datasource bean by wiring the db props into the data -->
	<bean id="dataSource" 
         class="org.springframework.jdbc.datasource.DriverManagerDataSource">
			<property name="driverClassName" value="${jdbc.driverClassName}" />
			<property name="url" value="${jdbc.url}" />
			<property name="username" value="${jdbc.username}" />
			<property name="password" value="${jdbc.password}" />
	</bean>
	
	<!-- ******************************* -->
	<!-- Configure a SI outbound adpater to log each message time 
		Should be able to configure this to 
	-->
	
	
	

 
	<int-event:inbound-channel-adapter channel="eventChannel" 
								 error-channel="eventErrorChannel"
								event-types="org.springframework.web.context.support.ServletRequestHandledEvent"/> 
     <int:publish-subscribe-channel id="eventChannel"/>
     <int:channel id="eventErrorChannel"></int:channel>

	<!-- ****** CONFIGURE SOME SPEL EXPRESSIONS TO TRACK TIMES 
				AT VARIOUS HOPS IN THE ROUTE 
				***********
	 -->
	
	  	<int-jdbc:outbound-channel-adapter
				id="jdbc-EventoutboundChannelAdapter"
				query="insert into lot_lu_loadtest_logger (
					    lo_message_start_time,
					    lo_message_controller_url,
					    lo_message_controller_time)
		    	values (:headers[timestamp],
		    			:url,
		    			:time)"
		    	data-source="dataSource" channel="eventChannel"
				sql-parameter-source-factory="spelSource" />

		<bean id="spelSource"
		      class="org.springframework.integration.jdbc.ExpressionEvaluatingSqlParameterSourceFactory">
		    <property name="parameterExpressions">
		        <map>
		            <entry key="createdDate" value="T(java.lang.System).currentTimeMillis()" />
		            <entry key="url" value="payload.getRequestUrl()" />
		            <entry key="time" value="payload.getProcessingTimeMillis()" />
		            </map>
		    </property>
		</bean>

		<int-jdbc:outbound-channel-adapter
		id="jdbc-WSoutboundChannelAdapter"
		query="insert into lot_lu_loadtest_logger (
			    lo_message_start_time, 
			    lo_message_test_id, 
			    lo_message_channel, 
			    lo_message_service,
			    lo_message_timestamp)
    	values (:headers[timestamp],
    			:headers[message_test_id],
    			:headers[message_source], 
    			:headers[message_service], 
    			:createdDate)"
		data-source="dataSource" channel="output"
		sql-parameter-source-factory="spelSource" />
		
		<int-jdbc:outbound-gateway
		id="jdbc-OutboundGateway"
		update="insert into lot_lu_loadtest_logger (
			    lo_message_start_time, 
			    lo_message_test_id, 
			    lo_message_channel, 
			    lo_message_service,
			    lo_message_timestamp)
    	values (:headers[timestamp],
    			:headers[message_test_id],
    			:headers[message_source], 
    			:headers[message_service], 
    			'test12')"
		data-source="dataSource" 
		request-channel="fromRabbit_voucher, fromRabbit_creditcard, fromRabbit_promotion, fromRabbit_loyalty" 
		/>
		

	<!-- ******************************* -->
	<!-- Configure a SI outbound adpater to log each message time -->
    
<!-- *********************************** 
		END  mySQL CONNECTION SETUP 
	***********************************  --> 


<!-- *********************************** 
		SET OF Consoler Out Adapter for testing etc
	*******************************  --> 
		
	
 <!-- *********************************** 
		End of Console-Out Adapter for testing etc 
	***********************************  --> 
	
	
	<!-- *********************************** 
		SETUP OF WEB SERIVCEC ADAPTERS THROUGH
		SPRING INTEGRATION 
	***********************************  --> 
 
	<!-- Setup of Web Service through Spring Integration -->
	

	<int:channel id="input" />
	<int:channel id="output" />
	
	<int-stream:stdout-channel-adapter
		id="consoleInput" 
		channel="input" 
		append-newline="true" 
	/>
	<int-stream:stdout-channel-adapter
		id="consoleOutPutEvent" 
		channel="output" 
		append-newline="true" 
	/>
	
	<int-stream:stdout-channel-adapter
		id="consoleOutPutEvent" 
		channel="eventErrorChannel" 
		append-newline="true" 
	/>
	
	
	 

<!--##############################################-->
<!-- Request message routing to OpenEx. -->
<!--##############################################-->
<!--  ****** LOCAL CONFIG ***** -->
<!--   
	<int-ws:outbound-gateway id="marshallingGateway"
		request-channel="input"
		reply-channel="output" 
		uri="http://localhost:8080/{message_service}/baskets" 
		marshaller="marshaller"
		unmarshaller="marshaller">
		<int-ws:uri-variable name="message_service" expression="headers.message_service"/>
	</int-ws:outbound-gateway>
 -->
<!--  ****** Cloudfoundry Config CONFIG ***** -->


<!--##############################################-->
<!-- This si the seciotn message routing to OpenEx. -->
<!--##############################################-->


	<int-ws:outbound-gateway id="marshallingGateway"
		request-channel="input"
		reply-channel="output" 
		uri="http://{message_service}.cloudfoundry.com/{message_service}/baskets" 
		marshaller="marshaller"
		unmarshaller="marshaller"
		>
		<!--  Very useful feature in Spring Integraiton as it allows for the 
			interrogation of messages headers/payload using Spring Expression Language -->
		<int-ws:uri-variable name="message_service" expression="headers.message_service"/>
		</int-ws:outbound-gateway>
		
		
</beans>
