<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
	xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
	xmlns:int="http://www.springframework.org/schema/integration"
	xmlns:context="http://www.springframework.org/schema/context"
	xmlns:int-amqp="http://www.springframework.org/schema/integration/amqp"
	xmlns:int-ws="http://www.springframework.org/schema/integration/ws"
	xmlns:rabbit="http://www.springframework.org/schema/rabbit"
	xmlns:int-stream="http://www.springframework.org/schema/integration/stream"
	xmlns:oxm="http://www.springframework.org/schema/oxm"
	xmlns:int-jdbc="http://www.springframework.org/schema/integration/jdbc"
	xmlns:jdbc="http://www.springframework.org/schema/jdbc"
	xmlns:aop="http://www.springframework.org/schema/aop"
	xmlns:cloud="http://schema.cloudfoundry.org/spring"
	xmlns:int-event="http://www.springframework.org/schema/integration/event"
	xsi:schemaLocation="http://www.springframework.org/schema/integration/amqp http://www.springframework.org/schema/integration/amqp/spring-integration-amqp.xsd
		http://www.springframework.org/schema/integration http://www.springframework.org/schema/integration/spring-integration.xsd
		http://www.springframework.org/schema/integration/ws http://www.springframework.org/schema/integration/ws/spring-integration-ws.xsd
		http://www.springframework.org/schema/integration/stream http://www.springframework.org/schema/integration/stream/spring-integration-stream.xsd
		http://www.springframework.org/schema/rabbit http://www.springframework.org/schema/rabbit/spring-rabbit.xsd
		http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd
		http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd
		http://www.springframework.org/schema/oxm http://www.springframework.org/schema/oxm/spring-oxm.xsd
	    http://www.springframework.org/schema/integration/jdbc http://www.springframework.org/schema/integration/jdbc/spring-integration-jdbc.xsd
	    http://www.springframework.org/schema/jdbc http://www.springframework.org/schema/jdbc/spring-jdbc.xsd
	    http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop.xsd
	    http://schema.cloudfoundry.org/spring http://schema.cloudfoundry.org/spring/cloudfoundry-spring.xsd
	    http://www.springframework.org/schema/integration/event http://www.springframework.org/schema/integration/event/spring-integration-event.xsd">
	    

	<context:component-scan base-package="ie.cit.cloud.mvc" />
	
	
	<!-- infrastructure setup -->



 	<rabbit:connection-factory id="connectionFactory" />
		<rabbit:template id="amqpTemplate" 
		connection-factory="connectionFactory" />
	
		<rabbit:admin connection-factory="connectionFactory" />
		<rabbit:queue name="epos.loyalty"  />
		<rabbit:queue name="epos.creditcard" />
		<rabbit:queue name="epos.promotion" />
		<rabbit:queue name="epos.voucher" />

	
	<!-- setup exchange/queue infrastructure, simple binding without routing key -->
	<rabbit:fanout-exchange name="epos.main.exchange.fanout">
		<rabbit:bindings>
			<rabbit:binding queue="epos.loyalty"  />
			 <rabbit:binding queue="epos.creditcard"  />
			<rabbit:binding queue="epos.promotion"  />
			<rabbit:binding queue="epos.voucher"  />  
		</rabbit:bindings>
	</rabbit:fanout-exchange>
	


	<int:annotation-config/>
	
	<!-- sending messages -->
	<int:channel id="toRabbit"></int:channel>
	<int-amqp:outbound-channel-adapter id="amqp-outbound-adapter" amqp-template="amqpTemplate"
		exchange-name="epos.main.exchange.fanout" channel="toRabbit"
		routing-key="epos.main.exchange.fanout"
		mapped-request-headers="message_*, __*, amqp_*" 
		/>
		



<!-- 
***
*** END OF AMQP SETUP
***
 -->
 
 
 
 
 
 <!-- 
***
*** THE FOLLOWING SECTION CONFIGURES THE MARSHELLERS REQUIRED FOR THE MESSAGING 
*** INFRASTRUCTURE AND THEN LEADS INTO THE THE 3RD PARTY WEB SERVICE CALLS
***
 -->


	<!-- Receiving messages from queues 
		These are then passed to a SI outbound web service adapter
		Before this can happen however, they need to be converted
		form Text to a Java object (handled by marshallingMessageConverter)
		This can simply be repeated for each Outbound Webservice as required
		thus making the application very scalable
	-->
	 <bean id="marshallingMessageConverter" class="org.springframework.amqp.support.converter.MarshallingMessageConverter">
	 		<property name="marshaller" ref="marshaller" />
	 		<property name="unmarshaller" ref="marshaller" />
	 </bean>
	 
	 <oxm:jaxb2-marshaller id="marshaller" contextPath="ie.cit.cloud.pointofsale"> 
	</oxm:jaxb2-marshaller>
	 <!-- access web service using spring integration -->
	 <!-- The JAXB elements to the can either scan the entire path such as : contextPath="ie.cit.cloud.pointofsale"
		OR 
		specify the individual classes to be bound
		<oxm:class-to-be-bound name="ie.cit.cloud.pointofsale.SalesTransactionRequest"/>
	    <oxm:class-to-be-bound name="ie.cit.cloud.pointofsale.LoyaltyResponse"/>
	    <oxm:class-to-be-bound name="ie.cit.cloud.pointofsale.CreditcardResponse"/>
	    <oxm:class-to-be-bound name="ie.cit.cloud.pointofsale.VoucherResponse"/>
	    <oxm:class-to-be-bound name="ie.cit.cloud.pointofsale.PromotionResponse"/>
		 -->


<!-- 
***
*** CALLS TO EXTERNAL THIRD PARTY WEB SERVICES USING 
*** SPRING INTEGRATION OUTBOUND WEB SERVICE ADAPTER
***
 -->
	<!-- 
	Access messages from the Fanout Exchange using and AMQP inbound adapter
	This message is then passed to the outbound LOYALTY WS adapter
	 -->

	<int-amqp:inbound-channel-adapter id="fromRabbit_loyalty_adapter"
	channel="fromRabbit_loyalty" 
	queue-names="epos.loyalty" 
	connection-factory="connectionFactory"  
	mapped-request-headers="message_*, __*, amqp_*"	
	message-converter="marshallingMessageConverter"
	error-channel="eventErrorChannel"
	/>
	<int:channel id="fromRabbit_loyalty"/>
	<int-ws:outbound-gateway id="loyaltyGateway"
		uri="http://loyalty.cloudfoundry.com/loyalty/baskets" marshaller="marshaller" unmarshaller="marshaller"
		request-channel="fromRabbit_loyalty"
		reply-channel="fromLoyaltyWS"
		
	/> 
	<!-- Need to converter the object response from the Web Service Outbound adapter back 
		to a json message as we will be handing it onto the Aggregator pattern which is expect a text/plain object 
		from the original AMQP fan-out exhange headers and message conversion.
	 -->
	 
	<int:channel id="fromLoyaltyWS" />
	<int:object-to-json-transformer id="fromWSObjecttoJSON"
	input-channel="fromLoyaltyWS" 
	output-channel="aggregateChannel" />
	
	

		
	<!-- 
	Access messages from the Fanout Exchange using and AMQP inbound adapter
	This message is then passed to the credit card outbound WS adapter
	 -->
	<int-amqp:inbound-channel-adapter 
	id="fromRabbit_creditcard_adapter"
	channel="fromRabbit_creditcard"
	queue-names="epos.creditcard" 
	connection-factory="connectionFactory"  
	mapped-request-headers="message_*, __*, amqp_*"	
	message-converter="marshallingMessageConverter"
	error-channel="eventErrorChannel"
	/>
	<int:channel id="fromRabbit_creditcard"/>
	<int-ws:outbound-gateway id="creditcardGateway"
		uri="http://creditcard.cloudfoundry.com/creditcard/baskets" marshaller="marshaller" 
		request-channel="fromRabbit_creditcard"
		reply-channel="fromCreditcardWS" 
	/> 
	<!-- Need to converter the object response from the Web Service Outbound adapter back 
		to a json message as we will be handing it onto the Aggregator pattern which is expect a text/plain object 
		from the original AMQP fan-out exchange headers and message conversion.
	 -->
	<int:channel id="fromCreditcardWS" />
	<int:object-to-json-transformer 
	input-channel="fromCreditcardWS" 
	output-channel="aggregateChannel" />
	
	<!-- 
	Access messages from the Fanout Exchange using and AMQP inbound adapter
	This message is then passed to the outbound WS adapter
	 -->
	<int-amqp:inbound-channel-adapter 
	id="fromRabbit_promotion_adapter"
	channel="fromRabbit_promotion"
	queue-names="epos.promotion" 
	connection-factory="connectionFactory"  
	mapped-request-headers="message_*, __*, amqp_*"	
	message-converter="marshallingMessageConverter"
	error-channel="eventErrorChannel"
	/>
	<int:channel id="fromRabbit_promotion"/>
	<int-ws:outbound-gateway id="promotionGateway"
		uri="http://promotion.cloudfoundry.com/promotion/baskets" marshaller="marshaller" unmarshaller="marshaller"
		request-channel="fromRabbit_promotion"
		reply-channel="fromPromotionWS" 
	/> 
	<!-- Need to converter the object response from the Web Service Outbound adapter back 
		to a json message as we will be handing it onto the Aggregator pattern which is expect a text/plain object 
		from the original AMQP fan-out exchange headers and message conversion.
	 -->
			<int:channel id="fromPromotionWS" />
			<int:object-to-json-transformer 
			input-channel="fromPromotionWS" 
			output-channel="aggregateChannel" />
	
		<!-- 
	Access messages from the Fanout Exchange using and AMQP inbound adapter
	This message is then passed to the outbound WS adapter
		<int:channel id="fromRabbit.epos.voucher"/>
		
	 -->

	<int-amqp:inbound-channel-adapter 
	id="fromRabbit_voucher_adapter"
	channel="fromRabbit_voucher"
	queue-names="epos.voucher" 
	connection-factory="connectionFactory"  
	mapped-request-headers="message_*, __*, amqp_*"	
	message-converter="marshallingMessageConverter"
	error-channel="eventErrorChannel"
	/>
	<int:channel id="fromRabbit_voucher"/>
	<int-ws:outbound-gateway id="voucherGateway"
		uri="http://voucher.cloudfoundry.com/voucher/baskets" marshaller="marshaller" unmarshaller="marshaller"
		request-channel="fromRabbit_voucher"
		reply-channel="fromVoucherWS" 
	/> 
	<!-- Need to converter the object response from the Web Service Outbound adapter back 
		to a json message as we will be handing it onto the Aggregator pattern which is expect a text/plain object 
		from the original AMQP fan-out exchange headers and message conversion.
	 -->
			<int:channel id="fromVoucherWS" />
			<int:object-to-json-transformer 
			input-channel="fromVoucherWS" 
			output-channel="aggregateChannel" />
	
	
	
	 
	<int:channel id="aggregateChannel"/>
	<int:aggregator input-channel="aggregateChannel"
		  output-channel="aggregateChannelOutput" 
		  correlation-strategy-expression="headers['amqp_receivedRoutingKey']"
		  release-strategy-expression="size() > 3"
		  send-partial-result-on-expiry="true"
		  send-timeout="5000"
		 />
		 
		 <!-- Simple call to outbound JDBC adapter to log the point at which all WebServices are
		 released by the aggregator pattern -->
		 
		<int:publish-subscribe-channel id="aggregateChannelOutput"/>
	 	<int-stream:stdout-channel-adapter id="aggregatestdOutput" channel="aggregateChannelOutput" append-newline="true" />
	
<!-- 
***
*** 		
*** END OF CALLS TO EXTERNAL THIRD PARTY WEB SERVICES USING 
*** SPRING INTEGRATION OUTBOUND WEB SERVICE ADAPTER
***
 -->
	
	
	
    
    
    <!-- *********************************** 
		 mySQL CONNECTION SETUP To Handle logging from
		 the JDBC Out-bound Adapter.
	***********************************  --> 
	<!-- Initialise the mySQL db -->
	<jdbc:initialize-database data-source="dataSource">
		<jdbc:script location="classpath:META-INF/mysql/db-schema.sql" />
	</jdbc:initialize-database>
 	<!-- Assign the db props placeholder -->
 	<bean 
 		class="org.springframework.beans.factory.config.PropertyPlaceholderConfigurer">
		<property name="location" >
				<value>classpath:META-INF/mysql/database.properties</value>  
		</property>
	</bean>
	
	<!-- Configure the datasource bean by wiring the db props into the data -->
	<bean id="dataSource" 
         class="org.springframework.jdbc.datasource.DriverManagerDataSource">
			<property name="driverClassName" value="${jdbc.driverClassName}" />
			<property name="url" value="${jdbc.url}" />
			<property name="username" value="${jdbc.username}" />
			<property name="password" value="${jdbc.password}" />
	</bean>
	

	<!-- ****** CONFIGURE SOME SPEL EXPRESSIONS TO TRACK TIMES 
				AT VARIOUS HOPS IN THE ROUTE 
				***********
	 -->

 
	<int-event:inbound-channel-adapter channel="eventChannel" 
								 error-channel="eventErrorChannel"
								event-types="org.springframework.web.context.support.ServletRequestHandledEvent"/> 
     <int:publish-subscribe-channel id="eventChannel"/>
     <int:channel id="eventErrorChannel"></int:channel>
<int-stream:stdout-channel-adapter
		id="consoleOutPutEvent" 
		channel="eventErrorChannel" 
		append-newline="true" 
	/>

	<int-jdbc:outbound-channel-adapter
		id="jdbc-EventoutboundChannelAdapter"
		query="insert into lot_lu_loadtest_logger (
					    lo_message_start_time,
					    lo_message_controller_url,
					    lo_message_controller_time)
		    	values (:headers[timestamp],
		    			:url,
		    			:time)"
		data-source="dataSource" channel="eventChannel"
		sql-parameter-source-factory="spelSource" />

	<bean id="spelSource"
		      class="org.springframework.integration.jdbc.ExpressionEvaluatingSqlParameterSourceFactory">
		    <property name="parameterExpressions">
		        <map>
		            <entry key="createdDate" value="T(java.lang.System).currentTimeMillis()" />
		            <entry key="url" value="payload.getRequestUrl()" />
		            <entry key="time" value="payload.getProcessingTimeMillis()" />
		            </map>
		    </property>
		</bean>

		<int-jdbc:outbound-channel-adapter
		id="jdbc-WSoutboundChannelAdapter"
		query="insert into lot_lu_loadtest_logger (
			    lo_message_start_time, 
			    lo_message_test_id, 
			    lo_message_channel, 
			    lo_message_service,
			    lo_message_timestamp)
    	values (:headers[timestamp],
    			:headers[message_test_id],
    			:headers[message_source], 
    			:headers[message_service], 
    			:createdDate)"
		data-source="dataSource" channel="output"
		sql-parameter-source-factory="spelSource" />
		
		<int-jdbc:outbound-gateway
		id="jdbc-OutboundGateway"
		update="insert into lot_lu_loadtest_logger (
			    lo_message_start_time, 
			    lo_message_test_id, 
			    lo_message_channel, 
			    lo_message_service,
			    lo_message_timestamp)
    	values (:headers[timestamp],
    			:headers[message_test_id],
    			:headers[message_source], 
    			:headers[message_service], 
    			'test12')"
		data-source="dataSource" 
		request-channel="aggregateChannelOutput" 
		/>
		

	<!-- ******************************* -->
	<!-- Configure a SI outbound adpater to log each message time -->
    
<!-- *********************************** 
		END  mySQL CONNECTION SETUP 
	***********************************  --> 


<!-- *********************************** 
		SET OF Consoler Out Adapter for testing etc
	*******************************  --> 
		
	
 <!-- *********************************** 
		End of Console-Out Adapter for testing etc 
	***********************************  --> 
	
	
	<!-- *********************************** 
		SETUP OF WEB SERIVCEC ADAPTERS THROUGH
		SPRING INTEGRATION 
	***********************************  --> 
 
	<!-- Setup of Web Service through Spring Integration -->
	

	<int:channel id="input" />
	<int:channel id="output" />
	
	<!-- 
	<int-stream:stdout-channel-adapter
		id="consoleInput" 
		channel="input" 
		append-newline="true" 
	/>
	
	<int-stream:stdout-channel-adapter
		id="consoleOutPutEvent" 
		channel="output" 
		append-newline="true" 
	/>
	-->
	
	
	
	 

<!--##############################################-->
<!-- Request message routing to OpenEx. -->
<!--##############################################-->
<!--  ****** LOCAL CONFIG ***** -->
<!--   
	<int-ws:outbound-gateway id="marshallingGateway"
		request-channel="input"
		reply-channel="output" 
		uri="http://localhost:8080/{message_service}/baskets" 
		marshaller="marshaller"
		unmarshaller="marshaller">
		<int-ws:uri-variable name="message_service" expression="headers.message_service"/>
	</int-ws:outbound-gateway>
 -->
<!--  ****** Cloudfoundry Config CONFIG ***** -->


<!--##############################################-->
<!-- This si the seciotn message routing to OpenEx. -->
<!--##############################################-->




	<int-ws:outbound-gateway id="marshallingGateway"
		request-channel="input"
		reply-channel="output" 
		uri="http://{message_service}.cloudfoundry.com/{message_service}/baskets" 
		marshaller="marshaller"
		unmarshaller="marshaller"
		>
		<!--  Very useful feature in Spring Integraiton as it allows for the 
			interrogation of messages headers/payload using Spring Expression Language -->
		<int-ws:uri-variable name="message_service" expression="headers.message_service"/>
		</int-ws:outbound-gateway>
		
		
</beans>
